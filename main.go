package main

import (
	// _ "./docs" // docs is generated by Swag CLI, you have to import it. LOCAL
	"crypto/subtle"
	"encoding/json"
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/secretsmanager"
	"github.com/aws/aws-sdk-go/service/sqs"
	"github.com/gorilla/mux"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"github.com/urfave/negroni"
	_ "goApp/docs" // docs is generated by Swag CLI, you have to import it. JENKINS
	"net/http"
	"os"
	"regexp"
	"time"

	httpSwagger "github.com/swaggo/http-swagger"
)

func timeCheck(t1 string, t2 string) (result bool, message string) {
	result = false
	message = "time ranges meet or exceed 60 minutes"
	date1, err := time.Parse(time.RFC3339, t1)
	if err != nil {
		log.Debug().Msg(err.Error())
		message = err.Error()
		return
	}

	date2, err := time.Parse(time.RFC3339, t2)
	if err != nil {
		log.Debug().Msg(err.Error())
		message = err.Error()
		return
	}
	duration := date2.Sub(date1)
	if duration.Minutes() < 60 {
		result = true
		message = ""
	}
	return result, message
}

// https://stackoverflow.com/questions/40326540/how-to-assign-default-value-if-env-var-is-empty
func getEnv(key, fallback string) string {
	if value, ok := os.LookupEnv(key); ok {
		log.Debug().Msg("Environmental variable configuration loaded from: " + key)
		return value
	}
	return fallback
}

type ApiParams struct {
	startTime, endTime, site, tagName string
}

func putMessageProcessApi(p ApiParams, queueName string) (returnString string, returnCode int) {

	sess := session.Must(session.NewSessionWithOptions(session.Options{
		SharedConfigState: session.SharedConfigEnable,
	}))

	svc2 := sqs.New(sess)

	urlResult, err := svc2.GetQueueUrl(&sqs.GetQueueUrlInput{
		QueueName: aws.String(queueName),
	})

	queueURL := urlResult.QueueUrl

	result, err := svc2.SendMessage(&sqs.SendMessageInput{
		MessageAttributes: map[string]*sqs.MessageAttributeValue{
			"startTime": &sqs.MessageAttributeValue{
				DataType:    aws.String("String"),
				StringValue: aws.String(cleanString(p.startTime)),
			},
			"endTime": &sqs.MessageAttributeValue{
				DataType:    aws.String("String"),
				StringValue: aws.String(cleanString(p.endTime)),
			},
			"site": &sqs.MessageAttributeValue{
				DataType:    aws.String("String"),
				StringValue: aws.String(cleanString(p.site)),
			},
			"tagName": &sqs.MessageAttributeValue{
				DataType:    aws.String("String"),
				StringValue: aws.String(cleanString(p.tagName)),
			},
		},
		MessageBody: aws.String(" "),
		QueueUrl:    queueURL,
	})

	if err != nil {
		returnString = string(err.Error())
		returnCode = 400
	} else {
		returnString = result.String()
		returnCode = 200
	}

	return returnString, returnCode

}

type MoveParams struct {
	source, destination string
}

func putMessageMoveMessages(p MoveParams, queueName string) (returnString string, returnCode int) {

	sess := session.Must(session.NewSessionWithOptions(session.Options{
		SharedConfigState: session.SharedConfigEnable,
	}))

	svc2 := sqs.New(sess)

	urlResult, err := svc2.GetQueueUrl(&sqs.GetQueueUrlInput{
		QueueName: aws.String(queueName),
	})

	queueURL := urlResult.QueueUrl

	result, err := svc2.SendMessage(&sqs.SendMessageInput{
		MessageAttributes: map[string]*sqs.MessageAttributeValue{
			"source": &sqs.MessageAttributeValue{
				DataType:    aws.String("String"),
				StringValue: aws.String(cleanString(p.source)),
			},
			"destination": &sqs.MessageAttributeValue{
				DataType:    aws.String("String"),
				StringValue: aws.String(cleanString(p.destination)),
			},
		},
		MessageBody: aws.String(" "),
		QueueUrl:    queueURL,
	})

	if err != nil {
		returnString = string(err.Error())
		returnCode = 400
	} else {
		returnString = result.String()
		returnCode = 200
	}

	return returnString, returnCode

}

func testUtcTime(test string) (result bool) {

	log.Trace().Msg("Processing: " + test)
	result = true
	output, err := regexp.MatchString(`\b[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}Z\b`, test)
	if err != nil {
		log.Trace().Msg("Could not process string")
		result = false
	}
	if output == false {
		log.Trace().Msg("output = false")
		result = false
	}
	return result
}

func cleanString(test string) (clean string) {
	if len(test) == 0 {
		clean = " "
	} else {
		clean = test
	}
	return clean
}

func endAPICall(w http.ResponseWriter, httpStatus int, anyStruct interface{}) {

	result, err := json.MarshalIndent(anyStruct, "", "  ")
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.WriteHeader(httpStatus)
	w.Write(result)
}

func BasicAuth(w http.ResponseWriter, r *http.Request, username, password, realm string) bool {

	user, pass, ok := r.BasicAuth()

	if !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {
		w.Header().Set("WWW-Authenticate", `Basic realm="`+realm+`"`)
		w.WriteHeader(401)
		w.Write([]byte("Unauthorised.\n"))
		return false
	}

	return true
}

func getSecret(secretName string, region_opt ...string) string {
	// make an envionmental var
	region := getEnv("region", "us-east-1")
	if len(region_opt) > 0 {
		region = region_opt[0]
	}

	//Create a Secrets Manager client
	svc := secretsmanager.New(session.New(),
		aws.NewConfig().WithRegion(region))
	input := &secretsmanager.GetSecretValueInput{
		SecretId:     aws.String(secretName),
		VersionStage: aws.String("AWSCURRENT"), // VersionStage defaults to AWSCURRENT if unspecified
	}

	result, err := svc.GetSecretValue(input)
	if err != nil {
		log.Error().Msg(string(err.Error()))
	}

	var secretString string
	if result.SecretString != nil {
		secretString = *result.SecretString
	}

	return secretString
}

func logMessages(rCode int, rText string) {
	if rCode == 400 {
		log.Warn().Msgf("Response text: \n %s", rText)
		log.Warn().Msgf("Response code: %d", rCode)
	} else {
		log.Trace().Msgf("Response text: \n %s", rText)
		log.Trace().Msgf("Response code: %d", rCode)
	}
}

// ApiManualReload godoc
// @Summary Move messages from one SQS queue to another
// @Description This is generally used for move messages from a DLQ to the source SQS.  **NOTE:** The queue names are case sensitive.
// @Tags Reload
// @Accept  json
// @Produce  json
// @param source query []string true "format: ?source=ne338-solar-back-fill-DLQ"
// @param destination query []string true "format: ?destination=ne338-solar-back-fill"
// @Success 200
// @Router /api/v1.0.0/manual-reload [post]
// @securityDefinitions.basic BasicAuth
// @in header
// @name Authorization
func apiManualReload(w http.ResponseWriter, r *http.Request) {

	source := r.FormValue("source")
	destination := r.FormValue("destination")
	responseCode := 200
	responsetext := "Scheduled SQS reload from " + source + " to " + destination
	responseError := "Cannot complete requested SQS move from " + source + " to " + destination

	if len(source) == 0 || len(destination) == 0 {
		responsetext = responseError + ", there is some required data missing."
		responseCode = 400
	}

	// convert to enviromental variable
	queueName := getEnv("sqs_reload_name", "ne338-solar-back-fill-manual-sqs-reload")

	result, code := putMessageMoveMessages(
		MoveParams{
			source:      source,
			destination: destination,
		},
		queueName)

	responsetext = responsetext + " - " + result
	responseCode = code

	logMessages(responseCode, responsetext)
	endAPICall(w, responseCode, responsetext)
}

// ApiManualLog godoc
// @Summary Triggers logging in SBI
// @Description This is used to manually trigger logging in SBI for one hour, optionally limited to a site.
// @Tags Logging
// @Accept  json
// @Produce  json
// @param startTime query []string true "format: ?startTime=2020-10-27T16:00:00Z"
// @param endTime query []string true "format: ?endTime=2020-10-27T16:59:59Z"
// @param site query []string false "format: ?site=SDS1"
// @Success 200
// @Router /api/v1.0.0/manual-log [post]
// @securityDefinitions.basic BasicAuth
// @in header
// @name Authorization
func apiManualLog(w http.ResponseWriter, r *http.Request) {

	startTime := r.FormValue("startTime")
	endTime := r.FormValue("endTime")
	site := r.FormValue("site")
	responseCode := 200
	responsetext := "Scheduled Logging run"
	responseError := "Cannot complete requested Logging run"

	if testUtcTime(startTime) == false || testUtcTime(endTime) == false {
		responsetext = responseError + ", there is some required data missing or in the incorrect format."
		responseCode = 400
	}

	if responseCode != 400 {
		timeResult, err := timeCheck(startTime, endTime)
		if timeResult == false {
			responsetext = responseError + " - " + err
			responseCode = 400

		}
	}

	if responseCode != 400 {

		// convert to enviromental variable
		queueName := getEnv("sqs_log_name", "ne338-solar-back-fill-manual-log")

		result, code := putMessageProcessApi(
			ApiParams{
				startTime: startTime,
				endTime:   endTime,
				site:      site,
			},
			queueName)

		responsetext = responsetext + " - " + result
		responseCode = code
	}

	logMessages(responseCode, responsetext)
	endAPICall(w, responseCode, responsetext)
}

// ApiManualProcess godoc
// @Summary Triggers processing data from CEWIS to SBI
// @Description This is used to manually trigger processing for up to an hour, optionally limited to a site and tag.
// @Tags Processing
// @Accept  json
// @Produce  json
// @param startTime query []string true "format: ?startTime=2020-10-27T16:00:00Z"
// @param endTime query []string true "format: ?endTime=2020-10-27T16:59:59Z"
// @param site query []string false "format: ?site=SDS1"
// @param tagName query []string false "format: ?tagName=123456a.dd.ee.ff.5"
// @Success 200
// @Router /api/v1.0.0/manual-process [post]
// @securityDefinitions.basic BasicAuth
// @in header
// @name Authorization
func apiManualProcess(w http.ResponseWriter, r *http.Request) {

	startTime := r.FormValue("startTime")
	endTime := r.FormValue("endTime")
	site := r.FormValue("site")
	tagName := r.FormValue("tagName")
	responseCode := 200
	responsetext := "Scheduled Process run"
	responseError := "Cannot complete requested Logging run"

	if testUtcTime(startTime) == false || testUtcTime(endTime) == false {
		responsetext = responseError + ", there is some required data missing or in the incorrect format."
		responseCode = 400
	}

	if responseCode != 400 {
		timeResult, err := timeCheck(startTime, endTime)
		if timeResult == false {
			responsetext = responseError + " - " + err
			responseCode = 400

		}
	}

	if responseCode != 400 {

		// handler for the date/time here

		// convert to enviromental variable
		queueName := getEnv("sqs_load_name", "ne338-solar-back-fill-manual-load")

		result, code := putMessageProcessApi(
			ApiParams{
				startTime:    startTime,
				endTime:      endTime,
				site:         site,
				tagName: tagName,
			},
			queueName)

		responsetext = responsetext + " - " + result
		responseCode = code
	}

	logMessages(responseCode, responsetext)
	endAPICall(w, responseCode, responsetext)
}

// ApiHealth godoc
// @Summary Health check endpoint
// @Description This is used for the load balancer and ECS to ensure the container is responding.
// @Tags Health
// @Accept  json
// @Produce  json
// @Success 200
// @Router /health/status [get]
func apiHealth(w http.ResponseWriter, r *http.Request) {
	endAPICall(w, 200, "Healthy")
}

type Config struct {
	Api_user     string `json:"api-user"`
	Api_password string `json:"api-password"`
}

func routers() *mux.Router {
	// pull from secrets manager

	configData := getSecret(getEnv("secret", "ne338-solar-back-fill"))
	var config Config
	json.Unmarshal([]byte(configData), &config)
	// fmt.Printf("Api_user: %s, Api_password: %s", config.Api_user, config.Api_password)

	username := getEnv("api_user", config.Api_user)
	password := getEnv("api_password", config.Api_password)

	// make an envionmental var
	apiVersion := "/api/" + getEnv("api_version", "v1.0.0")
	healthPath := "/" + getEnv("api_health_check", "health")

	baseRouter := mux.NewRouter().StrictSlash(true)
	healthRouter := mux.NewRouter().PathPrefix(healthPath).Subrouter().StrictSlash(true)
	securededRouter := mux.NewRouter().PathPrefix(apiVersion).Subrouter().StrictSlash(true)

	healthRouter.HandleFunc("/status", apiHealth).Methods("GET")

	securededRouter.HandleFunc("/manual-reload", apiManualReload).Methods("POST")
	securededRouter.HandleFunc("/manual-log", apiManualLog).Methods("POST")
	securededRouter.HandleFunc("/manual-process", apiManualProcess).Methods("POST")

	baseRouter.PathPrefix(healthPath).Handler(negroni.New(
		/* Health-check routes are unprotected */
		negroni.Wrap(healthRouter),
	))

	baseRouter.PathPrefix(apiVersion).Handler(negroni.New(
		negroni.HandlerFunc(func(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {
			if BasicAuth(w, r, username, password, "Provide user name and password") {
				next(w, r)
			}
		}),
		negroni.Wrap(securededRouter),
	))

	// Swagger
	baseRouter.PathPrefix("/swagger").Handler(httpSwagger.WrapHandler)

	return baseRouter
}

// @title CEWIS -> SBI Control API
// @version 1.0.0
// @description This is a service for managing the CEWIS -> SBI system
// @contact.name API Support
// @contact.email DL-SOLAR-CEWIS-BACKFILL-TEST@nexteraenergy.com
// @BasePath /
func main() {
	log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stderr, TimeFormat: time.RFC3339})
	zerolog.SetGlobalLevel(-1)

	logLevel := getEnv("log_level", "DEV")
	port := getEnv("api_port", "3001")
	log.Info().Msg("===========================================")
	log.Info().Msg("Starting up CEWIS -> SBI Control API server")
	log.Info().Msg("            Port: " + port)
	log.Info().Msg("       Log level: " + logLevel)
	log.Info().Msg("     Api Version: " + getEnv("api_version", "v1.0.0"))
	log.Info().Msg("    Health check: /" + getEnv("api_health_check", "health") + "/status")
	log.Info().Msg("===========================================")

	if logLevel == "DEV" {
		zerolog.SetGlobalLevel(-1)
	}
	if logLevel == "QA" {
		zerolog.SetGlobalLevel(1)
	}
	if logLevel == "PROD" {
		zerolog.SetGlobalLevel(2)
	}

	if r := routers(); r != nil {
		if err := http.ListenAndServe(":"+port, r); err != nil {
			log.Fatal().Err(err).Msg("Startup failed")
		}
	}

}
